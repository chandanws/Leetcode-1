这道题方法比较直接，直接遍历找live及dead的neighbors数量，然后更新矩阵即可。关键是如何保存之前状态，我们可以暴力的直接新建一个矩阵来作修改或者用两位int来暂时存原来状态及更新后的状态，高位表示下一步状态，低位表示原先状态，然后最后更新完后再遍历矩阵根据高位来把矩阵更新到最新状态。

往往这道题的follow up会围绕board的存储来展开，因为根本没必要用int来表示状态，太耗空间。最优存储方法是不用二维矩阵来表示，而是存所有live点的坐标。更新的方法就是扫一遍已存在的live点，扫其邻居，对其邻居而言，每被扫一次，次数加1， 用一个Map记录邻居及邻居被扫的次数，这些邻居最后会可能成为新的live点，最后根据Map里的value来确定新的live点。

